![](https://s1.vika.cn/space/2024/04/10/31bc82cf0d404552950be3ec8a46962a)

> ### *“与”运算的奇妙!**

```cpp
if(b & 1)
	ans *= base;

/*关于 b & 1：
“&”美名曰“按位与”。
x & y 是二进制 x 和 y 的每一位分别进行“与运算”的结果。
与运算，即两者都为 1 时才会返回 1，否则返回 0。
那么 b & 1

          二进制
b     =    1011
1     =    0001
b&1   =    0001

因为 1（二进制）的前面几位全部都是 0，
所以只有 b 二进制最后一位是 1 时，b & 1 才会返回 1。
挺巧妙的，并且很快。)*/

```



```cpp
#include<cstdio>
long long B,P,K;
//base ->底数
//p ->指数
long long qpow(int base,int p){
	long long ans=1,tmp=base;//从底数开始乘，不停自乘
	while(p!=0){//指数不是0 
		if(p&1){
			ans=(ans%K*tmp%K)%K;
		} 
		tmp=(tmp%K*tmp%K)%K;//自乘
		p=p>>1;//访问下一位 
	} 
	ans=ans%K;
	return ans;
} 
int main(){
	scanf("%lld%lld%lld",&B,&P,&K);
	long long ans=qpow(B,P);
	ans=ans%K;
	printf("%lld^%lld mod %lld=%lld",B,P,K,ans);
	return 0;
}

```

